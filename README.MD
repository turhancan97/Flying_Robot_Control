# Simulation of a Dynamic Flying Object

---

* **Author:** [Turhan Can KargÄ±n](https://github.com/turhancan97)
* **Topic:** Control of Flying Robots Laboratory Assignments

The repository was prepared for the **control of flying robots** lecture, which is one of the Poznan University of Technology Automatic Control and Robotics graduate courses. In this project, the aim is to simulate the control of flying robots in a dynamic environments.

---

Verifying a control algorithm for a flying robot is not a straightforward task. One option is to implement the algorithm on a real-life object, but this can be challenging due to the complex nature of the environment and the limitations of modeling the behavior of the object. Factors such as wind, rain, temperature, and pressure can significantly impact the behavior of the flying robot. Even the model of the robot itself may have important flaws, particularly due to the characteristics of the actuation systems, such as the forces generated by propellers or ailerons, which are dependent on many factors that may make the model impractical.

Numerical simulations, particularly those using computational fluid dynamics methods, can be useful at the initial stage of verification. However, it is important to be aware of the limitations of these simulations.

---

To simulate a dynamic object, such as an airplane flying at a fixed altitude, we can analyze its behavior in a plane, referred to as the XY-plane. The object, which can be approximated as a rigid body, is fully actuated and can generate propulsion forces along the X and Y axes of its local frame, as well as a torque that changes its orientation, represented by the angle of rotation between the global frame and the frame attached to the object.

In addition to these factors, we must also consider the effect of drag force on the object, which is proportional to its velocity squared and acts equally in all directions.

In summary, to simulate this dynamic object, we are making the following assumptions:

1. The object moves only in the XY-plane.
2. It has three degrees of freedom (3DOF), including movement in the X and Y directions and rotation about an axis perpendicular to the XY-plane.
3. It can be approximated as a rigid body.

The figure below show the flying object on the global and local frame.

<p align="center"><img src="docs/images/aeroplane_on_plane.png" width='350' height='250' alt="drawing"/></a></p>

## How to simulate
1. git clone `https://github.com/turhancan97/----.git`
1. Run `cd ----/<Project Folder Name>` on the terminal
1. Run `python test.py` on the terminal

## Results
### Simple Control Simulation

The code (test.py) appears to be a Python script for simulating the dynamics of an object, such as an airplane, and implementing a controller to track a desired trajectory.

The script begins by importing several libraries, including `numpy` for matrix operations, `scipy.integrate.solve_ivp` for solving differential equations, `matplotlib.pyplot` for plotting results, and `animation` for creating animations.

The script defines several functions, including `centrifugal_and_coriolis_forces`, which calculates the centrifugal and Coriolis forces on the object as a 3x3 matrix, and `damping_forces`, which calculates the damping forces on the object as a 1-dimensional array with 3 elements. The `Rba` function calculates the rotation matrix from frame b to frame a, and the trajectory function generates the desired trajectory at a given time t.

The controller function calculates the control inputs for the given state and desired trajectory, using the provided `K_p` gain. The dynamics function describes the dynamics of the object and calculates its acceleration as a function of its state and control inputs.

Finally, the script defines several variables, such as the `mass` and `damping coefficients` of the object, and calls the `solve_ivp` function to solve the differential equation representing the object's dynamics. The resulting trajectory is then plotted and animated.

The figures and animation below are generated for the flying object that has xd = 0, yd = 0, ttad = 0, ud = 1, vd = 0, rd = 0 desired trajectory to track and the object's state starts from xd = 1, yd = 1, ttad = 1, ud = 1, vd = 1, rd = 1.

<p align="left">
<img src="docs/images/measurement_by_time.png" width='500' height='300' alt="drawing"/>
</a>
<figcaption> Obtained Measurement by Time </figcaption>
</p>


<p align="left"><img src="docs/images/trajectories.png" width='500' height='300' alt="drawing"/></a>
<figcaption> Obtained Trajectories</figcaption></p>


<p align="left"><img src="docs/images/animation.gif" width='500' height='300' alt="drawing"/></a>
<figcaption>Animation</figcaption></p>


The `controller` function is responsible for calculating the control inputs for the object based on its current state and the desired trajectory. The control inputs are used to drive the object towards the desired trajectory.

The controller function takes three arguments:

- **xi:** A 6x1 array representing the current state of the object, including its position and velocity.
trajectory: A function that generates the desired trajectory at a given time t.
- **K_p:** A gain that determines how aggressively the control inputs should be applied to the object.

The controller function first calls the trajectory function to get the desired state at the current time. It then calculates the error between the current state and the desired state and scales it using the K_p gain. The resulting control inputs are then returned as a 1-dimensional array with 3 elements.

The trajectory function is responsible for generating the desired trajectory at a given time t. The desired trajectory represents the path that the object is intended to follow, and it is used as a reference for the controller to guide the object towards.

The trajectory function takes a single argument:

* t: A float representing the current time in seconds.
The trajectory function then defines the desired state at the current time, including the desired position and velocity of the object. This desired state is represented as a 6x1 array and returned by the function.
